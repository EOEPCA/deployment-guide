# Customized values for iam-bb.
# Note: For the EOEPCA 2.0.0-beta2 release, this file is *not* used for
# APISIX yet, though this would be supported in principle.
# So the relevant values for APISIX are still defined in apisix-values.yaml.

fullnameOverride: iam

global:
  storageClass: {{ getenv "STORAGE_CLASS" }}
  security:
    # Required for Keycloak custom image with OPA adapter
    allowInsecureImages: true

# Settings for the IAM BB chart as a whole.
# Some settings made here are propagated to the service-specific sections
# through anchors. Make sure not to remove the anchors and references,
# because otherwise the dependent values will not be set.
# Note that further adaptations may still be needed in the service-specific
# sections below.
iam: &iam
  keycloak:
    enabled: &keycloakEnabled true
    # "Official" Keycloak URL
    url: &kcurl {{ getenv "HTTP_SCHEME" }}://{{ getenv "KEYCLOAK_HOST" }}
    hosts:
      - auth.{{ getenv "INGRESS_HOST" }}
    paths:
      - /*
    # Optional configuration to apply as Crossplane CRs
    configuration: &kcConfig
      # Set this to true to enable generation of Crossplane CRs;
      # if set to false, Crossplane is not used and no CRs are generated.
      useCrossplane: false
      # Set to true to auto-generate clients as Crossplane CRs.
      createClients: false
      realm:
        # Set to true to auto-generate realm as Crossplane CR.
        create: false
        # Name of realm to create or of existing realm to create clients in
        name: eoepca
        displayName: EOEPCA
      provider:
        # Set to true to generate Provider config for Keycloak
        create: false
        # Reference to existing secret containing Keycloak location and credentials
        secretRef:
          name: keycloak-credentials
          key: credentials
          namespace: crossplane-system
  opa:
    {{- if eq ( getenv "INGRESS_CLASS" ) "apisix" }}
    enabled: &opaEnabled true
    createRoute: true
    {{- else }}
    enabled: &opaEnabled false
    createRoute: false
    {{- end }}

    hosts:
      - opa.{{ getenv "INGRESS_HOST" }}
    paths:
      - /*
    # Client credentials:
    # clientId is mandatory if clientSecret is specified or clientSecretRef is *not* specified.
    # Note: If both clientSecret and clientSecretRef are specified, a secret is generated
    # automatically, and the client secret is omitted from the route definition.
    clientId: {{ getenv "OPA_CLIENT_ID" }}
    clientSecret: {{ getenv "OPA_CLIENT_SECRET" }}
    #clientSecret:
    # clientSecretRef: Name of an existing secret that contains the client secret and maybe further values like the client ID
    #clientSecretRef: opa-route
  identityApi:
    enabled: &identityApiEnabled true
    {{- if eq ( getenv "INGRESS_CLASS" ) "apisix" }}
    createRoute: true
    {{- else }}
    createRoute: false
    {{- end }}
    hosts:
      - identity-api.{{ getenv "INGRESS_HOST" }}
    paths:
      - /*
    docsPath: /docs/*
    # Client credentials:
    # clientId is mandatory if clientSecret is specified or clientSecretRef is *not* specified.
    # Note: If both clientSecret and clientSecretRef are specified, a secret is generated
    # automatically, and the client secret is omitted from the route definition.
    clientId: {{ getenv "IDENTITY_API_CLIENT_ID" }}
    clientSecret: {{ getenv "IDENTITY_API_CLIENT_SECRET" }}
    #clientSecret:
    # clientSecretRef: Name of an existing secret that contains the client secret and maybe further values
    #clientSecretRef: identity-api-route
  apisix:
    enabled: &apisixEnabled false
  config:
    enabled: &configEnabled true

# ----

keycloak:
  enabled: *keycloakEnabled
  # default is "small" - see https://github.com/bitnami/charts/blob/main/bitnami/common/templates/_resources.tpl#L15
  # resourcesPreset: "large"
  image:
    # The following settings must point to a custom Keycloak image that includes the Keycloak OPA Plugin.
    registry: byud8gih.c1.de1.container-registry.ovh.net
    repository: eoepca/keycloak-with-opa-plugin
    tag: 0.5.0
    digest: ""
    pullPolicy: IfNotPresent
  auth:
    # Admin user credentials. If you specify a clear-text password here, you should make sure to change it
    # before making Keycloak publicly accessible. Alternatively, you may provide the password via an
    # existing (sealed) secret.
    adminUser: &adminUser {{ getenv "KEYCLOAK_ADMIN_USER" }}
    adminPassword: &adminPwd {{ getenv "KEYCLOAK_ADMIN_PASSWORD" }}
    existingSecret: ""
    passwordSecretKey: ""
  tls:
    # Set this to true to enable TLS
    enabled: false
    autoGenerated: true
  cors:
    # Set this to true to enable CORS
    enabled: true
  ## @param production Run Keycloak in production mode. TLS configuration is required except when using proxy=edge.
  ##
  production: false
  ## @param proxyHeaders Set Keycloak proxy headers
  ##
  proxyHeaders: "xforwarded"
  ## @param proxy reverse Proxy mode edge, reencrypt, passthrough or none
  ## ref: https://www.keycloak.org/server/reverseproxy
  ##
  #proxy: edge
  ## @param httpRelativePath Set the path relative to '/' for serving resources. Useful if you are migrating from older version which were using '/auth/'
  ## ref: https://www.keycloak.org/migration/migrating-to-quarkus#_default_context_path_changed
  ##
  httpRelativePath: "/"
  command: []
  ## @param args Override default container args (useful when using custom images)
  ##
  args: []
  ## @param extraEnvVars Extra environment variables to be set on Keycloak container
  extraEnvVars:
    # KC_SPI_POLICY_OPA_OPA_BASE_URI must point to the base URI of the OPA service.
    - name: KC_SPI_POLICY_OPA_OPA_BASE_URI
      value: "http://iam-opal-client.iam:8181/v1/data/"
    # KC_SPI_POLICY_OPA_OPA_POLICY_DIR points to a pod-internal config directory for
    # policies and should not be changed.
    - name: KC_SPI_POLICY_OPA_OPA_POLICY_DIR
      value: "/opt/bitnami/keycloak/conf/opa-policies"
    # KC_HOSTNAME and optionally KC_HOSTNAME_ADMIN should be set to the official base
    # URL of Keycloak (usually the same as iam.keycloak.url)
    - name: KC_HOSTNAME
      value: auth.{{ getenv "INGRESS_HOST" }}
    - name: KC_HOSTNAME_PORT
      value: "31443"
    - name: KC_HOSTNAME_STRICT_HTTPS
      value: "false"
    - name: KC_PROXY
      value: "edge"
  ## Service configuration
  ##
  service:
    ## @param service.type Kubernetes service type
    ##
    type: ClusterIP
    ## @param service.http.enabled Enable http port on service
    ##
    http:
      enabled: true
    ## @param service.ports.http Keycloak service HTTP port
    ## @param service.ports.https Keycloak service HTTPS port
    ##
    ports:
      http: 80
      https: 443
    ## @param service.nodePorts [object] Specify the nodePort values for the LoadBalancer and NodePort service types.
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    ##
    nodePorts:
      http: ""
      https: ""
    ## @param service.clusterIP Keycloak service clusterIP IP
    ## e.g:
    ## clusterIP: None
    ##
    clusterIP: ""
    ## @param service.loadBalancerIP loadBalancerIP for the SuiteCRM Service (optional, cloud specific)
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-loadbalancer
    ##
    loadBalancerIP: ""
    ## @param service.loadBalancerSourceRanges Address that are allowed when service is LoadBalancer
    ## https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
    ## Example:
    ## loadBalancerSourceRanges:
    ##   - 10.10.10.0/24
    ##
    loadBalancerSourceRanges: []
    ## @param service.externalTrafficPolicy Enable client source IP preservation
    ## ref https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
    ##
    externalTrafficPolicy: Cluster
    ## @param service.annotations Additional custom annotations for Keycloak service
    ##
    annotations: {}
    ## @param service.extraPorts Extra port to expose on Keycloak service
    ##
    extraPorts: []
  ## Keycloak ingress parameters
  ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
  ##
  ingress:
    enabled: false
  ## Keycloak admin ingress parameters
  ## ref: https://kubernetes.io/docs/user-guide/ingress/
  ##
  adminIngress:
    enabled: false
  postgresql:
    enabled: true
    auth:
      # postgresPassword: "..."
      username: bn_keycloak
      # password: "..."
      database: bitnami_keycloak
      existingSecret: "kc-postgres"
    architecture: standalone
    image:
      # Use PostgreSQL 16.4 for existing deployments instead of migrating the data
      tag: 16.4.0-debian-12-r14

opal:
  enabled: *opaEnabled
  # Override actual OPAL version to 0.8.0. Unfortunately though, this does not match the chart's app version and might be confusing.
  # Note: Commented out, thus defaults from Helm chart are used.
  #image:
  #  client:
  #    registry: docker.io
  #    repository: permitio/opal-client
  #    tag: 0.8.0
  #  server:
  #    registry: docker.io
  #    repository: permitio/opal-server
  #    tag: 0.8.0
  #  pgsql:
  #    registry: docker.io
  #    repository: postgres
  #    tag: alpine
  server:
    port: 7002
    policyRepoUrl: https://github.com/EOEPCA/iam-policies.git
    policyRepoSshKey: null
    policyRepoClonePath: null
    policyRepoMainBranch: main
    # Poll only every 5min for now. May be reduced or reconfigured to use webhooks if required.
    pollingInterval: 300
    dataConfigSources:
      # Option #1 - No data sources
      config:
        entries: []

      # Option #2 - Dynamically get data sources
      # external_source_url: "https://your-api.com/path/to/api/endpoint"

      # Option #3 - Example static data sources (endpoint is empty by default)
      # config:
      #   entries:
      #   - url: http://opal-server:7002/policy-data
      #     topics: ["policy_data"]
      #     dst_path: "/static"

      # Option #4 - Leave config empty and instead supply using the OPAL_DATA_CONFIG_SOURCES environment variable through env or secret
      # config: null

    broadcastUri: null
    broadcastPgsql: true
    uvicornWorkers: 4
    replicas: 1
    extraEnv: {
      # "CUSTOM_ENV_VAR": "VALUE"
    }

  client:
    port: 7000
    opaPort: 8181
    replicas: 1
    # If you need to specify a custom hostname for the opal-sever, configure the serverUrl property
    # serverUrl: http://custom-hostname-for-opal:opal-port
    opaStartupData:
      policy.rego: |
        # Simple example policy gives everyone read access to non-system documents
        # and only gives a root user full access.
        package system.authz
        import rego.v1
        jwks_request(url) := http.send({
          "url": url,
          "method": "GET",
          "force_cache": true,
          "force_cache_duration_seconds": 3600 # Cache response for an hour
        })
        jwks := jwks_request("http://iam-keycloak/realms/eoepca/protocol/openid-connect/certs").raw_body
        echo := input if {
          print(input)
        }
        # TESTING ONLY: Allow anything with a Authorization header
        default allow := true
        allow if {
          claims := io.jwt.decode(input.headers["Authorization"][0][7:])[1]
          print("Allowing everything for testing, Input: ", input, " Claims: ", claims)
        }
        default allow_policy_evaluation := false
        allow_policy_evaluation if {
          # Generally allow GET and POST on /v1/data/**
          #"GET" == input.method
          input.method in ["GET", "POST"]
          "v1" == input.path[0]
          "data" == input.path[1]
          "system" != input.path[2]
        }
        allow_policy_evaluation if {
          # Generally allow POST on /v1/query
          "POST" == input.method
          ["v1", "query"] == input.path
        }
        allow_policy_evaluation if {
          # Generally allow GET on /
          "GET" == input.method
          [""] == input.path
          print("GET /, Input: ", input)
        }
        # Claims from JWT if JWT is present and can be verified; null otherwise 
        default verified_claims = null
        verified_claims := claims if {
          [type, token] := split(input.headers["Authorization"][_], " ")
          type == "Bearer"
          io.jwt.verify_rs256(token, jwks) == true
          claims := io.jwt.decode(token)[1]
        }
        default allow := false
        allow if {
          # Allow everything for "root" identity
          "root$secret" == input.identity
          print("Root identity, Input: ", input)
        }
        allow if {
          # Preliminarily allow policy evaluation if Authorization header is unset,
          # i.e., if the request is anonymous, but originates from within the cluster
          not input.headers["Authorization"]
          allow_policy_evaluation == true
          print("AuthZ unset, Input: ", input)
        }
        allow if {
          # Allow authenticated users to evaluate policies 
          claims := verified_claims
          claims != null
          allow_policy_evaluation == true
          print("External, Input: ", input, " Claims: ", claims)
        }
        allow if {
          # Allow selected Werum users to GET arbitrary URLs 
          claims := verified_claims
          claims.email in ["w-scho@werum.de", "w-jfe@werum.de", "w-mwo@werum.de", "eoepcauser@eoepca.local"]
          input.method = "GET"
          print("External, Input: ", input, " Claims: ", claims)
        }
    extraEnv:
      OPAL_POLICY_STORE_URL: http://localhost:8181
      OPAL_POLICY_STORE_AUTH_TYPE: token
      OPAL_POLICY_STORE_AUTH_TOKEN: root$secret
      OPAL_INLINE_OPA_LOG_FORMAT: full
      OPAL_DATA_UPDATER_ENABLED: False
      OPAL_INLINE_OPA_CONFIG: >-
        {
          "addr": "http://0.0.0.0:8181",
          "authentication": "token",
          "authorization": "basic",
          "files": [ "/opt/opa/startup-data/policy.rego" ]
        }

apisix:
  enabled: *apisixEnabled
  service:
    # -- Apache APISIX service type for user access itself
    type: NodePort
    # -- Setting how the Service route external traffic
    # ref: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
    externalTrafficPolicy: Cluster
    externalIPs: []
  apisix:
    enableIPv6: false
    enableServerTokens: false
    ssl:
      enabled: true
      existingCASecret: "apx-all-tls"
      certCAFilename: "tls.crt"
    pluginAttrs:
      redirect:
        https_port: 443
  ingress-controller:
    enabled: true

# Configuration for iam-bb-config when applied as subchart
iamBbConfig:
  enabled: *configEnabled
  iam: *iam
  #config: *config

identityApi:
  enabled: *identityApiEnabled

identity-service:
  identity-postgres:
    enabled: false
  identity-keycloak:
    enabled: false
  identity-gatekeeper:
    enabled: false
  identity-api:
    enabled: *identityApiEnabled
    secrets: {}
      # Values for secret 'identity-api'
      # Note - if omitted, these can instead be set by creating the secret independently
      # e.g. as a SealedSecret via GitOps.
    #adminPassword: *adminPwd
    deployment:
      # Config values that can be passed via env vars
      extraEnv:
        - name: AUTH_SERVER_URL  # see configMap.authServerUrl instead
          value: "http://iam-keycloak.iam.svc.cluster.local"
        - name: ADMIN_USERNAME
          # Use dedicated identity-api user
          value: {{ getenv "KEYCLOAK_ADMIN_USER" }}
          #value: *adminUser
        - name: ADMIN_PASSWORD
          value: {{ getenv "KEYCLOAK_ADMIN_PASSWORD" }}
        - name: REALM
          value: "eoepca"
        # - name: VERSION
        #   value: v1.0.0
        - name: LOG_LEVEL
          value: DEBUG
