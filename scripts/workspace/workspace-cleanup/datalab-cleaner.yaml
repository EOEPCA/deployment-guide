apiVersion: v1
kind: ServiceAccount
metadata:
  name: datalab-session-cleaner
  namespace: workspace
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: datalab-session-cleaner
rules:
- apiGroups: [ "pkg.internal" ]
  resources: [ "datalabs" ]
  verbs: [ "get", "list", "watch", "patch" ]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: datalab-session-cleaner
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: datalab-session-cleaner
subjects:
- kind: ServiceAccount
  name: datalab-session-cleaner
  namespace: workspace
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: datalab-session-cleaner
  namespace: workspace
spec:
  schedule: "0 20 * * *"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: datalab-session-cleaner
          restartPolicy: Never
          containers:
          - name: cleaner
            image: dtzar/helm-kubectl:3.16.1
            imagePullPolicy: IfNotPresent
            command:
            - /bin/sh
            - -ceu
            - |
              RESOURCE_PLURAL="datalabs"
              API_GROUP="pkg.internal"
              kubectl get "${RESOURCE_PLURAL}.${API_GROUP}" -A -o json \
              | jq -c '.items[]' \
              | while read -r item; do
                  ns=$(echo "$item" | jq -r '.metadata.namespace // empty')
                  name=$(echo "$item" | jq -r '.metadata.name')
                  patch=$(echo "$item" | jq -c '{spec:{sessions: ((.spec.sessions // []) | map(select(. != "default")))}}')
                  if [ -n "$ns" ]; then
                    kubectl patch -n "$ns" "${RESOURCE_PLURAL}.${API_GROUP}" "$name" --type merge -p "$patch"
                  else
                    kubectl patch "${RESOURCE_PLURAL}.${API_GROUP}" "$name" --type merge -p "$patch"
                  fi
                done
