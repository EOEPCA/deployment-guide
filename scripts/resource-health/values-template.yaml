global:
  defaultInternalIssuerRef:
    name: {{ getenv "INTERNAL_CLUSTER_ISSUER" }}

opensearch:
  persistence:
    enabled: true
    storageClass: {{ getenv "PERSISTENT_STORAGECLASS" }}
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "no" }}
  singleNode: true
  replicas: 1
  resources:
    requests:
      memory: "512Mi"
      cpu: "200m"
{{- end }}
  securityConfig:
    config:
      data:
        roles_mapping.yml: |-
          _meta:
            type: "rolesmapping"
            config_version: 2

          all_access:
            backend_roles:
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "yes" }}
              - "opensearch_user"
{{- else }}
              - "admin"
{{- end }}
              - "all_access"
            users:
              - "admin"
              - "otel-collector"
        config.yml: |-
          _meta:
            type: "config"
            config_version: 2

          config:
            dynamic:
              kibana:
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "yes" }}
                multitenancy_enabled: true
{{- else }}
                multitenancy_enabled: false
{{- end }}
                server_username: 'dashboards-client'
                index: '.opensearch-dashboards'
              do_not_fail_on_forbidden: false

              http:
                anonymous_auth_enabled: false
              authc:
                basic_internal_auth_domain:
                  description: "Authenticate via HTTP Basic against internal users database"
                  http_enabled: true
                  transport_enabled: true
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "yes" }}
                  order: 2
{{- else }}
                  order: 1
{{- end }}
                  http_authenticator:
                    type: basic
                    challenge: true
                  authentication_backend:
                    type: intern
                clientcert_auth_domain:
                  description: "Authenticate via SSL client certificates"
                  http_enabled: true
                  transport_enabled: false
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "yes" }}
                  order: 1
{{- else }}
                  order: 2
{{- end }}
                  http_authenticator:
                    type: clientcert
                    config:
                      username_attribute: cn
                    challenge: false
                  authentication_backend:
                    type: noop
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "yes" }}
                openid_auth_domain:
                  http_enabled: true
                  transport_enabled: true
                  order: 0
                  http_authenticator:
                    type: openid
                    challenge: false
                    config:
                      subject_key: preferred_username
                      roles_key: roles
                      openid_connect_url: "{{ getenv "HTTP_SCHEME" }}://{{ getenv "KEYCLOAK_HOST" }}/realms/{{ getenv "REALM" }}/.well-known/openid-configuration"
                  authentication_backend:
                    type: noop
{{- end }}

opensearch-dashboards:
  config:
    opensearch_dashboards.yml:
      server:
        basePath: "/dashboards"
        ssl:
          enabled: false
      opensearch:
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "yes" }}
        requestHeadersAllowlist: [ authorization,securitytenant,x-access-token,x-id-token,x-userinfo,x-refresh-token ]
      opensearch_security:
        auth:
          type: "jwt"
{{- else }}
        requestHeadersAllowlist: [ authorization,securitytenant ]
{{- end }}

resource-health:
  telemetry_api:
    image:
      pullPolicy: Always
    replicaCount: 1
    environmentFixed:
      - name: FAST_API_ROOT_PATH
        value: "/api/telemetry"
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "yes" }}
      - name: OPEN_ID_CONNECT_URL
        value: "{{ getenv "HTTP_SCHEME" }}://{{ getenv "KEYCLOAK_HOST" }}/realms/{{ getenv "REALM" }}/.well-known/openid-configuration"
      - name: OPEN_ID_CONNECT_AUDIENCE
        value: "account"
{{- end }}
      - name: RH_TELEMETRY_API_DEFAULT_PAGE_SIZE
        value: "100"
      - name: RH_TELEMETRY_API_MAX_PAGE_SIZE
        value: "10000"

    use_hook_configmap: True
    hooks:
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "yes" }}
      oidc_auth_hooks.py: |
        from fastapi import Request
        import python_opentelemetry_access.telemetry_hooks.utils as hu
        from eoepca_security import OIDCProxyScheme, Tokens
        from typing import TypedDict
        import os


        class UserInfo(TypedDict):
            username: str | None
            access_token: str


        oidc_proxy_scheme = OIDCProxyScheme(
            openIdConnectUrl=os.environ["OPEN_ID_CONNECT_URL"],
            audience=os.environ["OPEN_ID_CONNECT_AUDIENCE"],
            id_token_header="x-id-token",
            refresh_token_header="x-refresh-token",
            auth_token_header="Authorization",
            auth_token_in_authorization=True,
            auto_error=True,
            scheme_name="OIDC behind auth proxy",
        )


        async def get_fastapi_security(request: Request) -> Tokens | None:
            return await oidc_proxy_scheme(request)


        def on_auth(tokens: Tokens | None) -> UserInfo:
            if tokens is None or tokens["auth"] is None:
                raise hu.APIForbiddenError(
                    title="Missing authentication token",
                    detail="Potentially missing authenticating proxy",
                )

            username_claim = (
                os.environ.get("RH_TELEMETRY_USERNAME_CLAIM") or "preferred_username"
            )

            return UserInfo(
                username=tokens["id"].decoded[username_claim]
                if tokens["id"] is not None and username_claim in tokens["id"].decoded
                else tokens["auth"].decoded["payload"].get(username_claim),
                access_token=tokens["auth"].raw,
            )


        def get_opensearch_config(userinfo: UserInfo) -> hu.OpensearchConfig:
            return hu.OpensearchConfig(
                hosts=[{"host": "opensearch-cluster-master-headless", "port": 9200}],
                use_ssl=True,
                verify_certs=True,
                ssl_show_warn=True,
                ca_certs="/certs/ca.crt",
                extra_headers={"Authorization": f"Bearer {userinfo['access_token']}"},
            )
{{- else }}
      noauth_hooks.py: |
        from fastapi import Request
        import python_opentelemetry_access.telemetry_hooks.utils as hu
        from typing import TypedDict


        class UserInfo(TypedDict):
            username: str | None


        async def get_fastapi_security(request: Request) -> None:
            """No authentication required - return None."""
            return None


        def on_auth(tokens: None) -> UserInfo:
            """Return a default demo user for unauthenticated access."""
            return UserInfo(username="demo-user")


        def get_opensearch_config(userinfo: UserInfo) -> hu.OpensearchConfig:
            """Configure OpenSearch connection with basic auth."""
            return hu.OpensearchConfig(
                hosts=[{"host": "opensearch-cluster-master-headless", "port": 9200}],
                use_ssl=True,
                verify_certs=True,
                ssl_show_warn=True,
                ca_certs="/certs/ca.crt",
                http_auth=("admin", "admin"),
            )
{{- end }}

  check_api:
    replicaCount: 1
    environmentFixed:
      - name: FAST_API_ROOT_PATH
        value: "/api/healthchecks"
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "yes" }}
      - name: OPEN_ID_CONNECT_URL
        value: "{{ getenv "HTTP_SCHEME" }}://{{ getenv "KEYCLOAK_HOST" }}/realms/{{ getenv "REALM" }}/.well-known/openid-configuration"
      - name: OPEN_ID_CONNECT_AUDIENCE
        value: "account"
{{- end }}

    use_hook_configmap: True
    hooks:
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "yes" }}
      disallow_frequent_check_hooks.py: |
        from datetime import datetime, timedelta
        from typing import TYPE_CHECKING, Any
        from cron_converter import Cron

        import check_hooks.hook_utils as hu

        if TYPE_CHECKING:
            from auth_hooks import UserInfo
        else:
            type UserInfo = Any


        def on_check_create(userinfo: UserInfo, check: hu.InCheckAttributes) -> None:
            print("ON CHECK CREATE from disallow_frequent_check_hooks.py")
            min_allowed_days_between_runs = 3
            if check.metadata.template_id == "telemetry_access_template":
                raise_error_if_schedule_too_frequent(
                    check.schedule,
                    min_allowed_days_between_runs=3,
                    error_detail=f"Check from template {check.metadata.template_id} must run at most once in {min_allowed_days_between_runs} day period.",
                )


        def raise_error_if_schedule_too_frequent(
            cron_schedule: str, min_allowed_days_between_runs: int, error_detail: str
        ) -> None:
            try:
                cron_instance = Cron(cron_schedule)
            except ValueError:
                raise hu.APIUserInputError(
                    title="Invalid schedule", detail="Invalid cron expression"
                )
            error = hu.APIUserInputError(title="Schedule Too Frequent", detail=error_detail)
            [minutes, hours, days, months, weekdays] = cron_instance.to_list()
            if len(minutes) > 1:
                raise error
            if len(hours) > 1:
                raise error
            start_date = datetime.now()
            schedule = cron_instance.schedule(start_date)
            prev_date = schedule.next()
            for i in range(365):
                date = schedule.next()
                if date - prev_date < timedelta(days=min_allowed_days_between_runs):
                    raise error
                if date - start_date > timedelta(days=365):
                    return
                prev_date = date
      oidc_auth_hooks.py: |
        import check_hooks.hook_utils as hu

        from eoepca_security import OIDCProxyScheme, Tokens
        from typing import TypedDict
        import os
        from fastapi import Request


        class UserInfo(TypedDict):
            userid: str
            username: str
            access_token: str
            refresh_token: str | None


        oidc_proxy_scheme = OIDCProxyScheme(
            openIdConnectUrl=os.environ["OPEN_ID_CONNECT_URL"],
            audience=os.environ["OPEN_ID_CONNECT_AUDIENCE"],
            id_token_header="x-id-token",
            refresh_token_header="x-refresh-token",
            auth_token_header="Authorization",
            auth_token_in_authorization=True,
            auto_error=True,
            scheme_name="OIDC behind auth proxy",
        )


        async def get_fastapi_security(request: Request) -> Tokens | None:
            return await oidc_proxy_scheme(request)


        def on_auth(tokens: Tokens | None) -> UserInfo:
            print("ON AUTH")

            if tokens is None or tokens["auth"] is None:
                hu.APIForbiddenError(
                    title="Missing authentication or ID token",
                    detail="Potentially missing authenticating proxy",
                )

            claims = {}
            claims.update(tokens["auth"].decoded["payload"])
            if tokens["id"] is not None:
                claims.update(tokens["id"].decoded)

            user_id_claim = os.environ.get("RH_CHECK_USER_ID_CLAIM") or "sub"
            username_claim = os.environ.get("RH_CHECK_USERNAME_CLAIM") or "preferred_username"

            user_id = claims.get(user_id_claim)
            username = claims.get(username_claim)

            if user_id is None or username is None:
                print(claims)
                raise hu.APIUnauthorizedError(
                    title="Missing user identification",
                    detail="Username or user id missing",
                )

            return UserInfo(
                userid=user_id,
                username=username,
                access_token=tokens["auth"].raw,
                refresh_token=tokens["refresh"].raw if tokens["refresh"] else None,
            )


        def on_template_access(userinfo: UserInfo, template: hu.CheckTemplate) -> None:
            print("ON TEMPLATE_ACCESS")

            if userinfo["username"] != "bob" and template.id != "simple_ping":
                return hu.CheckTemplateIdError(template.id)

            if userinfo["username"] not in ["bob", "alice", "eric"]:
                raise hu.CheckTemplateIdError(template.id)


        def on_check_create(userinfo: UserInfo, check: hu.InCheckAttributes) -> None:
            if userinfo["username"] == "eric" and check.metadata.template_id == "simple_ping":
                raise hu.APIForbiddenError(
                    title="Check creation disallowed",
                    detail="You are not authorized to create this check",
                )


        async def get_k8s_config(userinfo: UserInfo) -> hu.K8sConfiguration:
            return await hu.k8s_config_from_cluster()


        def get_k8s_namespace(userinfo: UserInfo) -> str:
            return "resource-health"


        async def on_k8s_cronjob_access(
            userinfo: UserInfo,
            check_id: hu.CheckId,
            client: hu.K8sClient,
            cronjob: hu.K8sCronJob,
        ) -> None:
            print("on_k8s_cronjob_access")

            if cronjob.metadata.annotations.get("owner") != userinfo["username"]:
                raise hu.CheckIdError(check_id)


        async def on_k8s_cronjob_create(
            userinfo: UserInfo, client: hu.K8sClient, cronjob: hu.K8sCronJob
        ) -> None:
            if (
                "owner" in cronjob.metadata.annotations
                and cronjob.metadata.annotations["owner"] != userinfo["username"]
            ):
                raise hu.APIForbiddenError(
                    title="Unauthorized check create",
                    detail="Permission denied to create health check cronjob",
                )

            cronjob.metadata.annotations["owner"] = userinfo["username"]

            secret_name = f"resource-health-{userinfo['username']}-offline-secret"
            secret_namespace = get_k8s_namespace(userinfo)

            offline_secret = await hu.lookup_k8s_secret(
                client=client,
                namespace=secret_namespace,
                name=secret_name
            )

            if offline_secret is None:
                if userinfo['refresh_token'] is None:
                    raise hu.APIException(
                        status="404",
                        code="MissingOfflineToken",
                        title="Missing Offline Token",
                        detail="Missing offline token, please create at least one check using the website",
                    )
                await hu.create_k8s_secret(
                    client=client,
                    name=secret_name,
                    namespace=secret_namespace,
                    string_data={
                        "offline_token": userinfo['refresh_token']
                    }
                )
{{- else }}
      noauth_hooks.py: |
        import check_hooks.hook_utils as hu
        from typing import TypedDict
        from fastapi import Request


        class UserInfo(TypedDict):
            userid: str
            username: str


        async def get_fastapi_security(request: Request) -> None:
            """No authentication required - return None."""
            return None


        def on_auth(tokens: None) -> UserInfo:
            """Return a default demo user for unauthenticated access."""
            return UserInfo(
                userid="demo-user-id",
                username="demo-user",
            )


        def on_template_access(userinfo: UserInfo, template: hu.CheckTemplate) -> None:
            """Allow access to all templates."""
            pass


        def on_check_create(userinfo: UserInfo, check: hu.InCheckAttributes) -> None:
            """Allow creation of all checks."""
            pass


        async def get_k8s_config(userinfo: UserInfo) -> hu.K8sConfiguration:
            """Get Kubernetes configuration from within the cluster."""
            return await hu.k8s_config_from_cluster()


        def get_k8s_namespace(userinfo: UserInfo) -> str:
            """Return the namespace for health check resources."""
            return "resource-health"


        async def on_k8s_cronjob_access(
            userinfo: UserInfo,
            check_id: hu.CheckId,
            client: hu.K8sClient,
            cronjob: hu.K8sCronJob,
        ) -> None:
            """Allow access to all cronjobs."""
            pass


        async def on_k8s_cronjob_create(
            userinfo: UserInfo, client: hu.K8sClient, cronjob: hu.K8sCronJob
        ) -> None:
            """Tag cronjob with owner on creation."""
            cronjob.metadata.annotations["owner"] = userinfo["username"]
{{- end }}

  web:
    replicaCount: 1
    environmentFixed:
      - name: NEXT_PUBLIC_CHECK_MANAGER_ENDPOINT
        value: {{ getenv "HTTP_SCHEME" }}://resource-health.{{ getenv "INGRESS_HOST" }}/api/healthchecks/v1
      - name: NEXT_PUBLIC_TELEMETRY_ENDPOINT
        value: {{ getenv "HTTP_SCHEME" }}://resource-health.{{ getenv "INGRESS_HOST" }}/api/telemetry/v1
      - name: NEXT_PUBLIC_RELOGIN_URL
        value: {{ getenv "HTTP_SCHEME" }}://resource-health.{{ getenv "INGRESS_HOST" }}/
      - name: NEXT_PUBLIC_QUERY_PAGE_SIZE
        value: "1000"

  healthchecks:
    use_template_configmap: True
    templates:
      ping_template.py: |
        import check_backends.k8s_backend.template_utils as tu

        SIMPLE_PING_SRC = """from os import environ
        import requests

        GENERIC_ENDPOINT: str = environ["GENERIC_ENDPOINT"]
        EXPECTED_STATUS_CODE: int = int(environ["EXPECTED_STATUS_CODE"])


        def test_ping() -> None:
            response = requests.get(
                GENERIC_ENDPOINT,
            )
            assert response.status_code == EXPECTED_STATUS_CODE
        """


        class SimplePingArguments(tu.BaseModel):
            model_config = tu.ConfigDict(extra="forbid")
            endpoint: str = tu.Field(json_schema_extra={"format": "textarea"})
            expected_status_code: int = tu.Field(ge=100, lt=600, default=200)


        SimplePing = tu.simple_runner_template(
            template_id="simple_ping",
            argument_type=SimplePingArguments,
            label="Simple ping template",
            description="Simple template with preset script for pinging single endpoint.",
            script_url=tu.src_to_data_url(SIMPLE_PING_SRC),
            runner_env=lambda template_args, userinfo: {
                "GENERIC_ENDPOINT": template_args.endpoint,
                "EXPECTED_STATUS_CODE": str(template_args.expected_status_code),
            },
            user_id=lambda template_args, userinfo: userinfo["username"],
            otlp_tls_secret="resource-health-healthchecks-certificate",
        )

      script_template.py: |
        import check_backends.k8s_backend.template_utils as tu


        class ScriptTemplateArguments(tu.BaseModel):
            model_config = tu.ConfigDict(extra="forbid")
            script: str = tu.Field(json_schema_extra={"format": "textarea"})
            requirements: str = tu.Field(json_schema_extra={"format": "textarea"}, default="")


        GenericScriptTemplate = tu.simple_runner_template(
            template_id="generic_script_template",
            argument_type=ScriptTemplateArguments,
            label="Generic script template",
            description="Runs a user-provided pytest script from a specified remote or data url",
            script_url=lambda template_args, userinfo: template_args.script,
            requirements_url=lambda template_args, userinfo: template_args.requirements,
            user_id=lambda template_args, userinfo: userinfo["username"],
            otlp_tls_secret="resource-health-healthchecks-certificate",
        )
{{- if eq (getenv "RESOURCE_HEALTH_ENABLE_OIDC") "yes" }}

      telemetry_access.py: |
        import check_backends.k8s_backend.template_utils as tu
        import os


        class TelemetryAccessArguments(tu.BaseModel):
            model_config = tu.ConfigDict(extra="forbid")
            script: str = tu.Field(json_schema_extra={"format": "textarea"})
            requirements: str = tu.Field(json_schema_extra={"format": "textarea"}, default="")


        TelemetryAccessTemplate = tu.simple_runner_template(
            template_id="telemetry_access_template",
            argument_type=TelemetryAccessArguments,
            label="Script with telemetry access",
            description="Health check template that runs a userscript with telemetry access on localhost:8080",
            script_url=lambda template_args, userinfo: template_args.script,
            requirements_url=lambda template_args, userinfo: template_args.requirements,
            user_id=lambda template_args, userinfo: userinfo["username"],
            otlp_tls_secret="resource-health-healthchecks-certificate",
            proxy=True,
            proxy_oidc_client_secret=(
                "resource-health-iam-client-credentials",
                "client_id",
                "client_secret",
            ),
            proxy_oidc_refresh_token_secret=lambda template_args, userinfo: (
                f"resource-health-{userinfo['username']}-offline-secret",
                "offline_token",
            ),
            proxy_oidc_url=os.environ.get("OPEN_ID_CONNECT_URL"),
        )
{{- end }}